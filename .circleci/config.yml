version: 2.1

executors:
  machine_executor:
    machine:
      image: ubuntu-2204:current  # Use a full VM image (Ubuntu 22.04)
      docker_layer_caching: true  # Optional: Enable Docker layer caching for faster builds
  python-executor:
    docker:
      - image: circleci/python:3.8
    working_directory: ~/project

commands:
  install_docker_compose:
    steps:
      - run:
          name: Install Docker Compose
          command: |
            sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
      - run:
          name: Verify Docker Compose Installation
          command: docker-compose --version

jobs:
  install_dependencies:
    executor: machine_executor
    steps:
      - checkout
      - run:
          name: Install Dependencies
          command: |
            
            # Update package lists and install dependencies
            sudo apt-get update
            
            # Install Python packages
            pip install pytest requests pylint

  test:
    executor: machine_executor
    steps:
      - checkout
      - install_docker_compose
      - run:
          name: Start Docker Daemon
          command: |
            sudo systemctl start docker  # Start Docker daemon in the machine executor
            sudo systemctl enable docker  # Enable Docker to start on boot
            sleep 5  # Wait for Docker daemon to fully initialize
      - run:
          name: Run Tests
          command: |
            docker volume create app_volume
            pip install pytest-html
            docker-compose -f docker-compose.test.yml up --build test-app || exit 1
      - run:
          name: Copy Test Reports
          command: |
            mkdir -p reports-xml
            mkdir -p reports-html
            docker cp flask-tests-container:/app/report.xml ./report.xml
            docker cp flask-tests-container:/app/report.html ./report.html

      - store_artifacts:
          path: ./report.xml
          destination: reports-xml

      - store_artifacts:
          path: ./report.html
          destination: reports-html


  build_docker_image:
    executor: machine_executor
    steps:
      - checkout
      - run:
          name: Build Docker Image
          command: |
            docker build -t $DOCKER_USERNAME/python-memcached:latest -f src/Dockerfile.app .
      - run:
          name: Push Docker Image
          command: |
            echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
            docker push $DOCKER_USERNAME/python-memcached:latest

  build_docker_image_tag:
    executor: machine_executor
    steps:
      - checkout
      - run:
          name: Build Docker Image
          command: |
            docker build -t $DOCKER_USERNAME/python-memcached:${CIRCLE_TAG} -f src/Dockerfile.app .
      - run:
          name: Push Docker Image
          command: |
            echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
            docker push $DOCKER_USERNAME/python-memcached:${CIRCLE_TAG}

  deploy_test_env:
    executor: python-executor
    environment:
      USER_KEY_PATH: id_kube_user_key
      SSH_PASSPHRASE: terraform
    steps:
      - checkout
      - add_ssh_keys:
          fingerprints:
            - "SHA256:E5222fhICNId9Z1YUdknmx+eax4SpL8p26sqEhtKjGQ"
      - run:
          name: Test Connection to GCP VM
          command: |
            ssh -o StrictHostKeyChecking=no \
            -i ~/.ssh/$USER_KEY_PATH \
            $KUBE_USER@$UBUNTU_GCP "echo 'Connection to GCP VM successful!'" || exit 1
#      - run:
#          name: Test SSH Connection
#          command: |
#            # Stop execution on any error
#            set -e
#
#            # Create the SSH directory if it doesn't exist
#            mkdir -p ~/.ssh
#
#            # Add the private SSH key to the specified path
#            echo -e "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$USER_KEY_PATH
#            chmod 600 ~/.ssh/$USER_KEY_PATH
#
#            # Start the SSH agent and add the key
#            eval $(ssh-agent -s)
#            ssh-add ~/.ssh/$USER_KEY_PATH
#
#            # Add host to known_hosts to prevent SSH errors
#            ssh-keyscan -H $UBUNTU_GCP >> ~/.ssh/known_hosts
#
#            # Test SSH connection with the specific key
#            ssh -o StrictHostKeyChecking=no -i ~/.ssh/$USER_KEY_PATH $KUBE_USER@$UBUNTU_GCP echo "Connection Successful" || exit 1
#
      

      - run:
          name: Set up Ansible
          command: |
            python -m pip install --upgrade pip
            pip install ansible

#      - run:
#          name: Set SSH Connectivity
#          shell: /bin/bash
#          command: |
#            set -e
#            mkdir -p ~/.ssh
#
#            if [ -z "$SSH_PRIVATE_KEY" ]; then
#              echo "Error: SSH_PRIVATE_KEY is not set."
#              exit 1
#            fi
#
#            echo -e "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/$USER_KEY_PATH
#            chmod 600 ~/.ssh/$USER_KEY_PATH
#
#            eval $(ssh-agent -s)
#
#            if [ -z "$SSH_PASSPHRASE" ]; then
#              echo "Error: SSH_PASSPHRASE is not set."
#              exit 1
#            fi
#
#            echo "$SSH_PASSPHRASE" | ssh-add ~/.ssh/$USER_KEY_PATH || exit 1

      - run:
          name: Test SSH Connection
          command: |
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/$USER_KEY_PATH $KUBE_USER@$UBUNTU_GCP || exit 1

      - run:
          name: Ping GCP Server with Ansible
          command: |
            echo "[target]" > inventory
            echo "$UBUNTU_GCP ansible_user=$KUBE_USER ansible_ssh_private_key_file=~/.ssh/$USER_KEY_PATH" >> inventory
            ansible -i inventory target -m ping || exit 1

      - run:
          name: Add $KUBE_USER to Docker group
          command: |
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/$USER_KEY_PATH $KUBE_USER@$UBUNTU_GCP "sudo groupadd -f docker && sudo usermod -aG docker $KUBE_USER" || exit 1

      - run:
          name: Restart session (optional)
          command: |
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/$USER_KEY_PATH $KUBE_USER@$UBUNTU_GCP "newgrp docker" || exit 1

      - run:
          name: Create docker-compose volume on GCP Server
          command: |
            echo "[target]" > inventory
            echo "$UBUNTU_GCP ansible_user=$KUBE_USER ansible_ssh_private_key_file=~/.ssh/$USER_KEY_PATH" >> inventory
            ansible all -i inventory -m shell -a "sudo docker volume create flask-app-data" || exit 1
            ansible all -i inventory -m shell -a "sudo docker volume create memcached-data" || exit 1

      - run:
          name: Copy docker-compose.yaml to GCP Server
          command: |
            echo "[target]" > inventory
            echo "$UBUNTU_GCP ansible_user=$KUBE_USER ansible_ssh_private_key_file=~/.ssh/$USER_KEY_PATH" >> inventory
            ansible -i inventory target -m copy -a "src=docker-compose.env.yml dest=/home/$KUBE_USER/docker-compose.env.yml mode=0644" || exit 1

      - run:
          name: Run docker-compose up -d and scale services
          command: |
            echo "[target]" > inventory
            echo "$UBUNTU_GCP ansible_user=$KUBE_USER ansible_ssh_private_key_file=~/.ssh/$USER_KEY_PATH" >> inventory
  
            if [ -n "${CIRCLE_TAG}" ]; then
              ansible -i inventory target -m shell -a \
                "cd /home/$KUBE_USER && sudo VERSION=${CIRCLE_TAG} docker-compose -f docker-compose.env.yml up -d" || exit 1
            else
              ansible -i inventory target -m shell -a \
                "cd /home/$KUBE_USER && sudo docker-compose -f docker-compose.env.yml up -d" || exit 1



workflows:
  version: 2
  build:
    jobs:
      - install_dependencies
      - test
      - build_docker_image:
          requires:
            - test
  build-tags:
    jobs:
      - build_docker_image_tag:
          filters:
            tags:
              only: /.*/
            branches:
              ignore: /.*/
      - deploy_test_env:
          requires:
            - build_docker_image_tag
          filters:
            tags:
              only: /.*/
            branches:
              ignore: /.*/
          







#version: 2.1
#
#executors:
#  docker_executor:
#    docker:
#      - image: circleci/python:3.8
#      - image: docker:20.10.7
#    working_directory: ~/project
#    environment:
#      DOCKER_HOST: tcp://localhost:2375
#      DOCKER_TLS_VERIFY: 0
#
#jobs:
#  install_dependencies:
#    executor: docker_executor
#    steps:
#      - checkout
#      - run:
#          name: Install Dependencies
#          command: |
#            sudo apt-get update
#            sudo apt-get install -y python3-pip curl docker.io
#            pip install pytest requests pylint
#
#
#  test:
#    executor: docker_executor
#    steps:
#      - checkout
#      - run:
#          name: Install Docker Compose
#          command: |
#            sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
#            sudo chmod +x /usr/local/bin/docker-compose
#      - run:
#          name: Verify Installation
#          command: docker-compose --version
#
#      - run:
#          name: Run Tests
#          command: |
#            docker volume create app_volume
#            pip install pytest-html
#            docker-compose -f docker-compose.test.yml up --build test-app || exit 1
#
#      - run:
#          name: Copy Test Reports
#          command: |
#            docker cp flask-tests-container:/app/report.xml ./report.xml
#            docker cp flask-tests-container:/app/report.html ./report.html
#      - store_test_results:
#          path: report.xml  # Store test reports for CircleCI
#      - store_artifacts:
#          path: report.html  # Optional: Store test reports as artifacts
#
#  build_docker_image:
#    executor: docker_executor
#    steps:
#      - checkout
#      - run:
#          name: Build Docker Image
#          command: |
#            docker build -t your_docker_username/python-memcached:${CIRCLE_TAG} -f ./Dockerfile.app .
#      - run:
#          name: Push Docker Image
#          command: |
#            echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
#            docker push your_docker_username/python-memcached:${CIRCLE_TAG}
#
#  deploy_test:
#    executor: docker_executor
#    steps:
#      - checkout
#      - run:
#          name: Deploy to Test Environment
#          command: |
#            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa user@host \
#              "cd /path/to/project && docker-compose -f docker-compose.env.yml up -d"
#
#  deploy_stage:
#    executor: docker_executor
#    steps:
#      - checkout
#      - run:
#          name: Setup kubectl
#          command: |
#            curl -LO "https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl"
#            chmod +x ./kubectl
#            mv ./kubectl /usr/local/bin/kubectl
#      - run:
#          name: Deploy to Stage Environment
#          command: |
#            export KUBECONFIG=/path/to/kubeconfig
#            kubectl apply -f deployment/manifest-memcached/configmap-memcached.yaml -n stage
#            kubectl apply -f deployment/manifest-memcached/memcached-statefulset.yaml -n stage
#            kubectl rollout status statefulset/memcached -n stage
#
#
#workflows:
#  version: 2
#  deploy_pipeline:
#    jobs:
#      - install_dependencies
#      - test:
#          requires:
#            - install_dependencies
##      - build_docker_image:
##          requires:
##            - test
##      - deploy_test:
##          requires:
##            - build_docker_image
##      - deploy_stage:
##          requires:
##            - build_docker_image
